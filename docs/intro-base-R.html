<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Jean-Baka Domelevo Entfellner" />

<meta name="date" content="2022-07-01" />

<title>Introduction to the base R language</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Learning R, RStudio and the tidyverse environment from scratch for agricultural research</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="installing-familiarizing.html">Installing R and RStudio</a>
</li>
<li>
  <a href="intro-base-R.html">First interactions with base R</a>
</li>
<li>
  <a href="playing-tidyverse.html">Exploring a dataset with tidyverse</a>
</li>
<li>
  <a href="Univariable%20Stats.pdf">Univariate stats</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    ADD workshop scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Addis_day1_am.R">Day 1 morning</a>
    </li>
    <li>
      <a href="Addis_day1_pm.R">Day 1 afternoon</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    NBO workshop scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="script_day1_am.R">Day 1 morning</a>
    </li>
    <li>
      <a href="script_day1_pm.R">Day 1 afternoon</a>
    </li>
    <li>
      <a href="whiteboard_scribblings_Tuesday.pdf">Whiteboard scribblings Day 1</a>
    </li>
    <li>
      <a href="script_day2_am.R">Day 2 morning</a>
    </li>
    <li>
      <a href="alal">Day 2 afternoon (stats)</a>
    </li>
    <li>
      <a href="script_day2_pm_JB.R">Day 2 afternoon (ggplot2)</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Sample datasets
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="fev_dataset.txt">fev_dataset.txt</a>
    </li>
    <li>
      <a href="livestockTLU.csv">livestockTLU.csv</a>
    </li>
    <li>
      <a href="livestock_data.xlsx">livestock_data.xlsx</a>
    </li>
    <li>
      <a href="Lungcancer.csv">Lungcancer.csv</a>
    </li>
  </ul>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Introduction to the base R language</h1>
<h4 class="author">Jean-Baka Domelevo Entfellner</h4>
<h4 class="date">2022-07-01</h4>

</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This tutorial walks you through basic interactions with the R
software package, from data manipulation to statistical tests and
regression models. You may start an interactive session with R either
directly from the shell by typing <code>R</code> on the commandline. Pay
attention that your GNU/Linux environment is case-sensitive, so typing
<code>r</code> will fail. Alternatively, you can start R through the
fancier Graphical User Interface (GUI) called RStudio: type
<code>rstudio</code> from the terminal, or (double-)click on the
corresponding icon on your desktop space.</p>
<p>During your interactive session with R, you type
<strong>commands</strong> or <strong>expressions</strong> in the
terminal (the frame called <em>Console</em> in RStudio), to which R will
either reply silently or display some result or perform some other
action (e.g. drawing a graph in a separate window frame). Whenever R is
ready to listen to you, it <strong>invites</strong> you to type in some
command with a tiny “greater than” sign at the very beginning of the
last line in the Console. In the examples you will find troughout this
tutorial, the interactions with R are reproduced in
<code>typewriter font</code>. So you don’t have to type in the initial
“greater than” sign when it is displayed at the beginning of a
commandline: this is simply the <strong>invite</strong> as produced by
R.</p>
<p>Once you are done with the present tutorial, if you want to deepen
your understanding of how R works, start to write some basic programs in
R, etc, I suggest that you read <a
href="https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf">that
excellent other tutorial written by Emmanuel Paradis</a> and entitled
<em>R for beginners</em>. It is a bit “old-school”, talking about the
base R programming style, but very instrumental in understanding how R
works.</p>
</div>
<div id="first-interactions" class="section level1">
<h1>First interactions</h1>
<div id="comments-in-r" class="section level2">
<h2>Comments in R</h2>
<p>This is really what we should start with. On a commandline, the hash
character (<code>#</code>) has a special meaning: the rest of the line,
including the hash character itself, is simply totally ignored by R.
This means that you can use it to enter comments in your code. Please
<strong>do comment</strong> massively your code, as it will make your
life easier when you will go back to saved file of R commands months
after you first wrote them: you will understand what they mean
exactly.</p>
</div>
<div id="variable-assignment" class="section level2">
<h2>Variable assignment</h2>
<p>In programming languages, storing some kind of data into the “memory”
of the computer (in fact into the current symbolic workspace defined by
your R session) is called <strong>assigning</strong> a value to a
variable. When you assign a value (whatever its type: it can be a string
of characters, an integer, a boolean variable, a floating-point number,
etc) to a variable, you create a new object with R. This is done through
the <strong>assignment operator</strong> <code>-&gt;</code>. This
operator is written with a hyphen (<code>-</code>) followed by a
“greater than” sign (<code>&gt;</code>), so that it forms an arrow.
Taking care of swapping the two operands (variable and value), this can
be also written the other way around:</p>
<pre class="r"><code>&gt; 5 -&gt; a    # puts the value 5 into the variable a
&gt; b &lt;- 7    # puts the value 7 into the variable b 
&gt; b - a     # asks for the evaluation (calculation) of b-a </code></pre>
<pre><code>[1] 2</code></pre>
<pre class="r"><code>&gt; 2         # nothing prevents you from evaluating a constant!</code></pre>
<pre><code>[1] 2</code></pre>
<p>The “greater than” character that appears at the beginning of the
line (in a terminal or in RStudio’s <em>Console</em> frame is the
<strong>invite</strong>. It means that R is waiting for you to enter a
<strong>command</strong>. Some commands produce a silent output
(e.g. assigning a value to a variable is a silent operation), some other
display a result. For example, subtracting the content of the variable
called <code>a</code> from the content of the variable called
<code>b</code> gives the single value <code>2</code> as an output.
Notice that the <code>[1]</code> automatically prepended to the output
line is <strong>an index</strong>: as R tends to see everything as a
<strong>vectorized variable</strong> (you will see other examples very
soon), here it tells us that this <code>2</code> is the first element of
the output vector produced by the operation <code>b-a</code> (this
output vector contains only one element). On the last line of the
interaction above, you can see that even typing a mere value and asking
R to <strong>evaluate</strong> it by pressing the (Enter) key yields the
exact same output with the exact same formatting.</p>
</div>
<div id="vectors-and-function-calls" class="section level2">
<h2>Vectors and function calls</h2>
<p>As we just said, <strong>vectors</strong> are essential data
structures in R. One creates vectors simply by using the concatenation
operator (or function), rightfully named <code>c</code>:</p>
<pre class="r"><code>&gt; myvec &lt;- c(1,3,5,7,84) # passing five integers as arguments to the function c
&gt; myvec                  # myvec is now a vector containing five elements</code></pre>
<pre><code>[1]  1  3  5  7 84</code></pre>
<pre class="r"><code>&gt; length(myvec)          # calling the function length on the object myvec</code></pre>
<pre><code>[1] 5</code></pre>
<p>Here we have just used our first two <strong>functions</strong> in R.
With the first command of this interaction block, we performed a
<strong>function call</strong> to the function called <code>c</code>,
giving it five integers as arguments. A function call in R is always
written as this: the name of the function is followed by a pair of
parentheses enclosing a list of comma-separated arguments (possibly only
one or even none). Hence, the last operation we performed above is a
function call to the function <code>length</code>, passing to it one
argument only, namely the <code>myvec</code> variable.</p>
<p>Remember that whenever you want to <strong>use</strong> a function,
you <strong>have to</strong> write these parentheses. Even if the
function needs no argument. For instance, the function <code>ls</code>,
when invoked (another vocable computer people use for “called”) with no
argument, <strong>lists</strong> the content of your current “userspace”
or “environment”: it returns a vector populated with strings giving the
names of these objects present in your current R environment (i.e. the
variables you defined earlier in your interactive session).</p>
<pre class="r"><code>&gt; ls()</code></pre>
<pre><code> [1] &quot;a&quot;            &quot;av1&quot;          &quot;av2&quot;          &quot;av3&quot;          &quot;av4&quot;         
 [6] &quot;av5&quot;          &quot;av6&quot;          &quot;b&quot;            &quot;blood_groups&quot; &quot;dat1&quot;        
[11] &quot;filter&quot;       &quot;households&quot;   &quot;iris2&quot;        &quot;iris3&quot;        &quot;last_row&quot;    
[16] &quot;list1&quot;        &quot;list2&quot;        &quot;mat1&quot;         &quot;mat2&quot;         &quot;mat3&quot;        
[21] &quot;mat4&quot;         &quot;mat5&quot;         &quot;my_column&quot;    &quot;mydat&quot;        &quot;mydir&quot;       
[26] &quot;myvec&quot;        &quot;oldnames&quot;     &quot;responses&quot;    &quot;subset1&quot;      &quot;transformed&quot; 
[31] &quot;vec&quot;         </code></pre>
<p>Beware!! If you omit the parentheses, R will try and evaluate
<strong>the function itself</strong>:</p>
<pre class="r"><code>&gt; ls</code></pre>
<pre><code>function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern, sorted = TRUE) 
{
    if (!missing(name)) {
        pos &lt;- tryCatch(name, error = function(e) e)
        if (inherits(pos, &quot;error&quot;)) {
            name &lt;- substitute(name)
            if (!is.character(name)) 
                name &lt;- deparse(name)
            warning(gettextf(&quot;%s converted to character string&quot;, 
                sQuote(name)), domain = NA)
            pos &lt;- name
        }
    }
    all.names &lt;- .Internal(ls(envir, all.names, sorted))
    if (!missing(pattern)) {
        if ((ll &lt;- length(grep(&quot;[&quot;, pattern, fixed = TRUE))) &amp;&amp; 
            ll != length(grep(&quot;]&quot;, pattern, fixed = TRUE))) {
            if (pattern == &quot;[&quot;) {
                pattern &lt;- &quot;\\[&quot;
                warning(&quot;replaced regular expression pattern &#39;[&#39; by  &#39;\\\\[&#39;&quot;)
            }
            else if (length(grep(&quot;[^\\\\]\\[&lt;-&quot;, pattern))) {
                pattern &lt;- sub(&quot;\\[&lt;-&quot;, &quot;\\\\\\[&lt;-&quot;, pattern)
                warning(&quot;replaced &#39;[&lt;-&#39; by &#39;\\\\[&lt;-&#39; in regular expression pattern&quot;)
            }
        }
        grep(pattern, all.names, value = TRUE)
    }
    else all.names
}
&lt;bytecode: 0x55b89ec11408&gt;
&lt;environment: namespace:base&gt;</code></pre>
</div>
<div id="getting-some-help" class="section level2">
<h2>Getting some help</h2>
<p>To get some help on a command, just type a question mark
(<code>?</code>) immediately followed by the name of the command. If
using the commandline R, you will then enter a manpage-like environment,
in which the <code>space</code> moves you to the next screen (or page),
the <code>b</code> key goes back one page, and a keypress on
<code>q</code> quits the help and brings you back to the commandline and
its invite. Alternatively, depending on the configuration of your
computer, you may get access to the HTML version of the help pages: that
will be the case for most of us, using RStudio: the manpage is displayed
in a nice, html format in the bottom right pane. By the way, in RStudio,
you can also ask for manpages by clicking on the <code>Help</code> tab
in the bottom right pane, and then using the search box in the upper
right corner of that pane to enter a search keyword. You don’t need to
type the question marks when using that searchbox.</p>
<pre class="r"><code>&gt; ?ls
&gt; #.... viewing the help on the ls command in the help pane
&gt; 
&gt; ?length
&gt; # .... viewing the help on the length command in the help pane
&gt; 
&gt; ??transpose
&gt; #  .... viewing the help pages containing the transpose keyword in the help pane</code></pre>
<p>The latter type of query (with the double question mark) is to be
used when you are unsure of the name of the function you are seeking
help about. It tries to provide you with the list of help files
containing the keyword in question, after what you will prepend the
single question mark to the name of the identified command (or function)
to get the relevant help page.</p>
<p>These help pages (also called <strong>manpages</strong>) are all
built according to the same structure: after a short
<em>Description</em> of the purpose of the command, follows a section
called <em>Usage</em>. This latter section presents the syntax you may
use to build a function call, with the possible options to specify and
their possible default values. For instance, in the help about the
<code>c</code> function, the <em>Usage</em> section reads as follows
:</p>
<blockquote>
<pre><code>c(..., recursive = FALSE)</code></pre>
</blockquote>
<p>We are told here that the <code>c</code> function takes several
arguments first (an undefined number thereof) and then expects an
optional parameter named <code>recursive</code>. We know it is optional
because of the equal sign and the specified value put thereafter: when
the user omits to specify a value for that parameter, R will silently
set its value to <code>FALSE</code>.</p>
<p>This is a general rule for the behaviour of functions in R: when an
equal sign appears in the <em>Usage</em> section right after the name of
an argument, it means that in case the corresponding argument is
omitted, it is silently given the said value by R (i.e.~the value
appearing on the right of that equal sign). This makes function call
writing very flexible, as one can omit some of the arguments when one is
fine with the default values.</p>
<p>For instance, you may try the following:</p>
<pre class="r"><code>&gt; list1 &lt;- list(1,2)   # the list function builds a list from its argument
&gt; list2 &lt;- list(3,4)
&gt; c(list1,list2)       # don&#39;t pay too much attention to the way R writes lists</code></pre>
<pre><code>[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3

[[4]]
[1] 4</code></pre>
<pre class="r"><code>&gt; c(list1,list2,recursive=FALSE) # produces the exact same output as the previous command</code></pre>
<pre><code>[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3

[[4]]
[1] 4</code></pre>
<pre class="r"><code>&gt; c(list1,list2,recursive=TRUE)</code></pre>
<pre><code>[1] 1 2 3 4</code></pre>
<p>In other terms, here the function call finally executed when the user
enters <code>c(list1,list2)</code> is indeed
<code>c(list1,list2,recursive=FALSE)</code>: the default value for the
argument has been used.</p>
<p>Back into the manpage, the section named <em>Arguments</em> explains
the role and valid values of the different arguments (or options) of the
function, and the <em>Details</em> section gives further in-depth
explanations about the behaviour of the function and the results it
yields.</p>
</div>
<div id="different-data-different-modes" class="section level2">
<h2>Different data, different modes</h2>
<p>R can manipulate different types of data. Whenever you input some
data into R, these data are given a <strong>mode</strong>, and this mode
affects the way R deals with them.</p>
<pre class="r"><code>&gt; mode(0.1)</code></pre>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>&gt; mode(&quot;allo&quot;)</code></pre>
<pre><code>[1] &quot;character&quot;</code></pre>
<pre class="r"><code>&gt; mode(2 &gt; 5)</code></pre>
<pre><code>[1] &quot;logical&quot;</code></pre>
<pre class="r"><code>&gt; mode(1+2i)</code></pre>
<pre><code>[1] &quot;complex&quot;</code></pre>
<pre class="r"><code>&gt; mode(TRUE)</code></pre>
<pre><code>[1] &quot;logical&quot;</code></pre>
<pre class="r"><code>&gt; mode(T)   # &quot;T&quot; is a short for TRUE. FALSE may also be written &quot;F&quot;</code></pre>
<pre><code>[1] &quot;logical&quot;</code></pre>
<p>Non-atomic constructs also inherit the mode of their components:</p>
<pre class="r"><code>&gt; a = c(1,1)   # yes, variable assignment can also be written this most simple way... ;)
&gt; mode(a)</code></pre>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>&gt; a = c(&quot;ab&quot;,&quot;ba&quot;)
&gt; mode(a)</code></pre>
<pre><code>[1] &quot;character&quot;</code></pre>
<p>The two logical values in R are <code>TRUE</code> and
<code>FALSE</code>. You may use instead their shorter versions
<code>T</code> and <code>F</code>. Attention: use these symbols “as is”.
Enclosing them into quotes would not give the boolean values but mere
strings (mode <em>character</em>).</p>
</div>
</div>
<div id="data-structures-in-r-vectors-matrices-and-data-frames"
class="section level1">
<h1>Data structures in R: vectors, matrices and data frames</h1>
<p> We’ve already seen the <code>c</code> function to create vectors. A
vector is a special R construct used to store an array of items all
having the same mode. Vectors made of evenly spaced numeric items are
called <strong>sequences</strong>. These are created with the
<code>seq</code> command. The following three commands produce the very
same result:</p>
<pre class="r"><code>&gt; c(1,2,3,4,5)</code></pre>
<pre><code>[1] 1 2 3 4 5</code></pre>
<pre class="r"><code>&gt; seq(from=1, to=5, by=1)</code></pre>
<pre><code>[1] 1 2 3 4 5</code></pre>
<pre class="r"><code>&gt; 1:5</code></pre>
<pre><code>[1] 1 2 3 4 5</code></pre>
<p>Notice that the second command uses <strong>argument naming</strong>:
<code>seq(from=1, to=5, by=1)</code>. This is optional but convenient in
many cases, and highly recommended in the specific case of
<code>seq</code>. We will see other examples of function calls with
explicit argument naming later on. In order to understand how the
<code>seq</code> function works, please refer to its help page (command
<code>?seq</code> or <code>help("seq")</code>). There you can see
(<em>Usage</em> section, a.k.a~“synopsis” of the command/function) that
the first three arguments expected by <code>seq</code> are named
respectively <code>from</code>, <code>to</code> and <code>by</code> (the
first one is the lower bound of the sequence to be generated, the second
is the upper bound and the third is the step value).</p>
<p>Keep in mind the <code>1:5</code> trick to quickly build a sequence
of consecutive integers. We will make use of that later. Also notice
that <code>seq</code> comes useful to sample regularly an interval on
the real line, e.g.~<code>x = seq(from=0, to=1, by=0.01)</code> builds a
vector of 101 points evenly spaced on the real interval <span
class="math inline">\([0,1]\)</span>, both boundaries included, and
stores the result into the variable <code>x</code>.</p>
<p>Finally, we mention the <code>rep</code> function that helps you
build a vector with a repetitive content. For instance, if we want to
build a vector of 10 values all equal to 1:</p>
<pre class="r"><code>&gt; rep(1,10)</code></pre>
<pre><code> [1] 1 1 1 1 1 1 1 1 1 1</code></pre>
<p>This also applies to build a repetition of a pattern of length <span
class="math inline">\(&gt; 1\)</span>:</p>
<pre class="r"><code>&gt; rep(1:3,4)</code></pre>
<pre><code> [1] 1 2 3 1 2 3 1 2 3 1 2 3</code></pre>
<div id="indexing-and-altering-elements" class="section level2">
<h2>Indexing and altering elements</h2>
<p>In a vector, each element is addressable by its
<strong>index</strong>. The usual square bracket notation applies.
Vector indices start at 1, and vector elements are mutable: one can
alter directly one of the values in a vector without reassigning the
whole vector.</p>
<pre class="r"><code>&gt; a = c(10,11,12,13)
&gt; a[2]</code></pre>
<pre><code>[1] 11</code></pre>
<pre class="r"><code>&gt; a[2] &lt;- 20
&gt; a</code></pre>
<pre><code>[1] 10 20 12 13</code></pre>
<p>One can also take a slice from an existing vector, extracting
consecutive elements:</p>
<pre class="r"><code>&gt; a[2:4]</code></pre>
<pre><code>[1] 20 12 13</code></pre>
</div>
<div id="going-multidimensional-matrices" class="section level2">
<h2>Going multidimensional: matrices</h2>
<p>Our first attempt to build a 2x2 matrix could be as follows:</p>
<pre class="r"><code>&gt; mat1=c(c(1,2),c(3,4))
&gt; mat1</code></pre>
<pre><code>[1] 1 2 3 4</code></pre>
<pre class="r"><code>&gt; length(mat1)</code></pre>
<pre><code>[1] 4</code></pre>
<p>So it doesn’t work like that: the <code>c</code> command flattens all
the arguments it is given to build only <strong>one</strong> long
vector. We have to use the function <code>matrix</code> to build a
matrix:</p>
<pre class="r"><code>&gt; mat1 = matrix(data=c(1,2,3,4), nrow=2, ncol=2)
&gt; mat1</code></pre>
<pre><code>     [,1] [,2]
[1,]    1    3
[2,]    2    4</code></pre>
<p>Note that <strong>by default R fills in the data structure by
columns</strong>: it fills up the first column with the first data and
then proceeds to the second column with the remaining data, etc. This is
beacause the default value for the <code>byrow</code> option of the
<code>matrix</code> command is set to <code>FALSE</code> (see the
manpage of <code>matrix</code>, e.g.~typing <code>?matrix</code> after
the invite). To proceed row-wise, you must explicitly specify
<code>byrow=T</code> (see our examples further below).</p>
<p>We said earlier that <strong>vectorization is often implicit in
R</strong>. Here are some examples:</p>
<pre class="r"><code>&gt; mat2 = matrix(data=5, nrow=2, ncol=3)
&gt; mat2</code></pre>
<pre><code>     [,1] [,2] [,3]
[1,]    5    5    5
[2,]    5    5    5</code></pre>
<pre class="r"><code>&gt; mat3 = matrix(data=c(1,2), nrow=3, ncol=2, byrow=T)
&gt; mat3</code></pre>
<pre><code>     [,1] [,2]
[1,]    1    2
[2,]    1    2
[3,]    1    2</code></pre>
<p>R automatically replicates the input data to pan to the size of the
container (here, a 3x2 matrix).</p>
<p>A matrix is in fact a special form of vector: it has a length and a
mode (and only one mode: try to mix strings and numbers in the same
matrix and see what happens), but also an additional feature, its
<strong>dimension</strong>, that one can query (and alter) through the
function <code>dim</code>.</p>
<pre class="r"><code>&gt; length(mat3)</code></pre>
<pre><code>[1] 6</code></pre>
<pre class="r"><code>&gt; mode(mat3)</code></pre>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>&gt; dim(mat3)</code></pre>
<pre><code>[1] 3 2</code></pre>
<pre class="r"><code>&gt; dim(mat3) = c(1,6)
&gt; mat3</code></pre>
<pre><code>     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    1    1    2    2    2</code></pre>
<p>Accessing elements from a matrix is done also with the usual square
bracket notation:</p>
<pre class="r"><code>&gt; mat4=matrix(data=1:20, ncol=5, byrow=T)
&gt; mat4</code></pre>
<pre><code>     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
[3,]   11   12   13   14   15
[4,]   16   17   18   19   20</code></pre>
<pre class="r"><code>&gt; mat4[2,3]</code></pre>
<pre><code>[1] 8</code></pre>
<pre class="r"><code>&gt; mat4[,3]</code></pre>
<pre><code>[1]  3  8 13 18</code></pre>
<pre class="r"><code>&gt; mat4[1,]</code></pre>
<pre><code>[1] 1 2 3 4 5</code></pre>
<p>These last two commands are very important to understand. These are
the first and simplest examples of <strong>subsetting</strong> that we
see: here we extract the third column of <code>mat4</code>, and then its
first row. In both cases the results are vectors. <code>mat4[,]</code>
would simply give the entire <code>mat4</code>. All sorts of selection
patterns can be used in combination.</p>
<p>For instance:</p>
<pre class="r"><code>&gt; mat4[,2:4]</code></pre>
<pre><code>     [,1] [,2] [,3]
[1,]    2    3    4
[2,]    7    8    9
[3,]   12   13   14
[4,]   17   18   19</code></pre>
<p>Of course, as the resulting matrix is a new object, with no memory of
the data container it originates from, indexing in it starts anew from
1.</p>
</div>
<div id="applying-functions-to-variables-with-implicit-vectorization"
class="section level2">
<h2>Applying functions to variables with implicit vectorization</h2>
<p>In R, the “modulo” operator (you know, that operator giving the
remainder in the euclidean division of its two operands) is written
<code>%%</code>. Its two operands (on its left and on its right) are
expected to be numbers:</p>
<pre class="r"><code>&gt; 17 %% 5</code></pre>
<pre><code>[1] 2</code></pre>
<p>But in fact we can also use this operator to find out all the
remainders modulo 2 from a matrix:</p>
<pre class="r"><code>&gt; transformed = mat4 %% 2
&gt; transformed</code></pre>
<pre><code>     [,1] [,2] [,3] [,4] [,5]
[1,]    1    0    1    0    1
[2,]    0    1    0    1    0
[3,]    1    0    1    0    1
[4,]    0    1    0    1    0</code></pre>
<pre class="r"><code>&gt; sum(transformed)</code></pre>
<pre><code>[1] 10</code></pre>
<p>Fair enough: out of this matrix of 20 consecutive integers, 10 are
odd numbers. The modulo operator has worked in a vectorized fashion: it
has been applied to every element of its input, producing on output of
same dimensionality. What’s more, we can actually extract from
<code>mat4</code> all its elements with zero remainder in the division
by 3, with the single following selection command:</p>
<pre class="r"><code>&gt; mat4[mat4 %% 3 == 0]</code></pre>
<pre><code>[1]  6 12  3 18  9 15</code></pre>
<p>As in most programming languages, <strong>in R the boolean operator
to test for equality is </strong><code>==</code>, obviously because
<code>=</code> is one of the operators used for variable assignment. We
are using it in the command above to select a subset of the indices in
<code>mat4</code>, extracting from it the elements whose Euclidean
division by 3 yields a zero remainder (i.e.~we are extracting the
elements of <code>mat4</code> that are divisible by 3). Now let us try
to use the same kind of selection pattern to count the number of A’s and
G’s in a large matrix made of nucleotides. Our 10x42 matrix is made of
repeated patterns of five nucleotides (A, C, A, T, G): there will be
twice as many A’s as any of the other three nucleotides.</p>
<pre class="r"><code>&gt; mat5=matrix(c(&#39;A&#39;,&#39;C&#39;,&#39;A&#39;,&#39;T&#39;,&#39;G&#39;),nrow=10,ncol=42,byrow=T)
&gt; mat5[1,] # just to check the first line...</code></pre>
<pre><code> [1] &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot;
[19] &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot;
[37] &quot;C&quot; &quot;A&quot; &quot;T&quot; &quot;G&quot; &quot;A&quot; &quot;C&quot;</code></pre>
<pre class="r"><code>&gt; mat5 == &quot;G&quot;  # vectorized comparison to &quot;G&quot;</code></pre>
<pre><code>       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11] [,12]
 [1,] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
 [2,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
 [3,]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
 [4,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
 [5,] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
 [6,] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
 [7,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
 [8,]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
 [9,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
[10,] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
      [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24]
 [1,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
 [2,]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
 [3,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
 [4,] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
 [5,] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
 [6,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
 [7,]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
 [8,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
 [9,] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
[10,] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
      [,25] [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36]
 [1,]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
 [2,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
 [3,] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
 [4,] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
 [5,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
 [6,]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE
 [7,] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE
 [8,] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE
 [9,] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
[10,] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
      [,37] [,38] [,39] [,40] [,41] [,42]
 [1,] FALSE FALSE FALSE  TRUE FALSE FALSE
 [2,] FALSE  TRUE FALSE FALSE FALSE FALSE
 [3,] FALSE FALSE FALSE FALSE  TRUE FALSE
 [4,] FALSE FALSE  TRUE FALSE FALSE FALSE
 [5,]  TRUE FALSE FALSE FALSE FALSE  TRUE
 [6,] FALSE FALSE FALSE  TRUE FALSE FALSE
 [7,] FALSE  TRUE FALSE FALSE FALSE FALSE
 [8,] FALSE FALSE FALSE FALSE  TRUE FALSE
 [9,] FALSE FALSE  TRUE FALSE FALSE FALSE
[10,]  TRUE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>&gt; length(mat5[mat5==&quot;G&quot;])</code></pre>
<pre><code>[1] 84</code></pre>
<p>Note that the two boolean/logical values <code>TRUE</code> and
<code>FALSE</code> are automatically translated into respectively 1 and
0 when forced in an arithmetic operation for instance the
<code>sum</code> operation as illustrated below. This makes it extremely
convenient to <strong>count the number of elements in a vector that
fulfill a given requirement</strong>:</p>
<pre class="r"><code>&gt; sum(mat5==&quot;G&quot;)</code></pre>
<pre><code>[1] 84</code></pre>
<pre class="r"><code>&gt; sum(mat5==&quot;A&quot;) # correct result: 168 = 2 * 84</code></pre>
<pre><code>[1] 168</code></pre>
<p>It is worth here commenting further about the selection scheme based
on a test (i.e. an expression being evaluated into a boolean value or an
array of boolean values, i.e.~an R object in <em>logical</em> mode)
enclosed into square brackets that are appended to the name of a
variable. While in the above examples the array we took a subset from
(<code>mat4</code> or <code>mat5</code>) was also appearing in the
selection pattern (e.g. <code>mat5[mat5=='G']</code>), this is not a
constraint imposed by R. One can extract elements from a vector
according to a criterion determined on some other vector, possibly
unrelated to the first one. For example:</p>
<pre class="r"><code>&gt; myvec = 1:20
&gt; filter = rep(c(T,F,F,T,F),4)      # logical vector unrelated to myvec\ldots
&gt; length(filter)                    # \ldots but with same size</code></pre>
<pre><code>[1] 20</code></pre>
<pre class="r"><code>&gt; myvec[filter]</code></pre>
<pre><code>[1]  1  4  6  9 11 14 16 19</code></pre>
</div>
<div id="working-with-categorical-variables-factors"
class="section level2">
<h2>Working with categorical variables: factors</h2>
<p>A <strong>categorical</strong> variable can take only a finite number
of different values, usually from quite a small set. Examples are for
instance: * a nucleotide can be encoded as a categorical variable,
taking one of four values represented e.g. with the four letters A,C,G
and T; * human blood groups are taken from the set {A,B,AB,O} (four
categories or levels); * from the Martin-Schultz scale, one could
classify human iris colours in the seven following categories: amber,
blue, brown, gray, green, hazel, red/violet; * a question from survey
could accept responses <em>high</em>, <em>medium</em> or <em>low</em>
(three categories our levels); * a disease allele can be either dominant
or recessive (two categories or levels).</p>
<p>Please note that some categorical variables come with no specific
logical ordering (e.g. human iris colors), while some other (we call
them <strong>ordinal</strong> variables) do: for instance the
high/medium/low categories.</p>
<p>In R, the different values a categorical variable can possibly have
are called <strong>levels</strong>. Defining categorical variables is
done through the <code>factor</code> function. One has to pay attention
to the fact that this function is at the same time the instanciation of
a vector and the declaration of the <strong>type</strong> of its
elements. Possible values that would not exist in the specific vector we
are declaring should be named through the argument called
<code>labels</code>.</p>
<p>For a start, let us define the blood groups of 8 patients:</p>
<pre class="r"><code>&gt; blood_groups = factor(c(&#39;A&#39;,&#39;B&#39;,&#39;A&#39;,&#39;B&#39;,&#39;A&#39;,&#39;O&#39;,&#39;AB&#39;,&#39;A&#39;))
&gt; blood_groups</code></pre>
<pre><code>[1] A  B  A  B  A  O  AB A 
Levels: A AB B O</code></pre>
<p>Please refer to the manpage for <code>factor</code>: in the example
above we only use the first argument of this function (called
<code>x</code>) in the manpage. Here it is a vector made of strings, but
it could also have been a vector of integers. R automatically deduces
the four possible levels for this categorical variable, as in this
example at least one instance of each is present. The resulting
variable, <code>blood_groups</code>, is a vector <strong>plus</strong>
the information of the possible levels of the underlying categorical
variable. Note the difference with:</p>
<pre class="r"><code>&gt; blood_groups=c(&#39;A&#39;,&#39;B&#39;,&#39;A&#39;,&#39;B&#39;,&#39;A&#39;,&#39;O&#39;,&#39;AB&#39;,&#39;A&#39;)
&gt; blood_groups</code></pre>
<pre><code>[1] &quot;A&quot;  &quot;B&quot;  &quot;A&quot;  &quot;B&quot;  &quot;A&quot;  &quot;O&quot;  &quot;AB&quot; &quot;A&quot; </code></pre>
<p>In this latter example, <code>blood_groups</code> is simply a vector
of strings, with no underlying idea of categories.</p>
<p>If we need to tell R that levels exist that are not present in the
vector we define, we have to use the second argument of the
<code>factor</code> function, called <code>labels</code> in its
manpage:</p>
<pre class="r"><code>&gt; blood_groups=factor(c(&#39;A&#39;,&#39;B&#39;,&#39;A&#39;), levels=c(&#39;A&#39;,&#39;B&#39;,&#39;AB&#39;,&#39;O&#39;))
&gt; blood_groups</code></pre>
<pre><code>[1] A B A
Levels: A B AB O</code></pre>
<p>If we want to define <strong>ordinal</strong> data, we put the right
ordering in the <code>levels</code> argument and set the boolean option
<code>ordered</code> to <code>TRUE</code>. Note the informative way used
by R to display that ordering along with the vector of categorical
data:</p>
<pre class="r"><code>&gt; responses = factor(c(&#39;low&#39;,&#39;low&#39;,&#39;high&#39;,&#39;low&#39;), levels=c(&#39;low&#39;,&#39;med&#39;,&#39;high&#39;), ordered=T)
&gt; responses</code></pre>
<pre><code>[1] low  low  high low 
Levels: low &lt; med &lt; high</code></pre>
<p>To sum it up, let us remember that factors are some kind of vectors
that contain the information relative to the possible levels or
categories. The function <code>levels</code> gives you direct access to
these.</p>
</div>
<div id="data-frames" class="section level2">
<h2>Data frames</h2>
<p>Data frames are complex data containers in R. While vectors (and
their matrix derivatives) cannot store data of different types (try to
build <code>c(1,2,"three")</code>), data frames can sotre different
types of data in different <strong>fields</strong> (i.e.~different
columns). To get our first example of a data frame, and as we don’t know
yet how to import data from our data files, we load some data readily
available in R through the variable called <code>iris</code>. These are
observations of a number of plant specimens, all belonging to the
<em>Iris</em> genus. For each specimen, geometrical features of the
petal and sepal are recorded, as well as its classification name at the
species level. As this data frame is rather large, typing
<code>iris</code> on the commandline dumps the whole dataframe to the
screen in a rather inconvenient way. Let us introduce the very useful
and very versatile function <code>str</code> (for “structure”) that
provides insight on the structure of just any R object:</p>
<pre class="r"><code>&gt; str(iris)</code></pre>
<pre><code>&#39;data.frame&#39;:   150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
<pre class="r"><code>&gt; # and to get all the levels associated to the Species field:
&gt; levels(iris$Species)</code></pre>
<pre><code>[1] &quot;setosa&quot;     &quot;versicolor&quot; &quot;virginica&quot; </code></pre>
<p>We learn that the <code>iris</code> variable is of type
<code>data.frame</code> and contains 150 observations
(<strong>records</strong> or rows) or 5 variables
(<strong>fields</strong> or columns). The first four fields contain
numeric variables and are named <code>Sepal.Length</code>,
<code>Sepal.Width</code>, <code>Petal.Length</code> and
<code>Petal.Width</code>, while the fifth field contains a categorical
variable being the name of the species. We are told that only three
different species (and thus 3 different levels) exist in the dataset:
<em>Iris setosa</em>, <em>Iris versicolor</em> and <em>Iris
virginica</em>. To get all the information relative to the levels of the
field named <code>Species</code>, we type
<code>levels(iris$Species)</code>: the dollar sign is used to designate
a field of a data frame. Besides the information concerning the size of
the data container, field names, type of data, etc, <code>str</code>
displays the first values found in every field. Note that the internal
representation of categorical variables by R may rely on integers. These
are not to be typed in by the user but gives you an idea of how
efficient categorical variable storage is in R.</p>
<p>Another useful and versatile function to have a glance at a complex
set of data is <code>summary</code>, which gives an account of the
distribution of categorical variables as well as a basic statistical
summary of all numerical variables:</p>
<pre class="r"><code>&gt; summary(iris)</code></pre>
<pre><code>  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   
 Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  
 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  
 Median :5.800   Median :3.000   Median :4.350   Median :1.300  
 Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  
 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  
 Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  
       Species  
 setosa    :50  
 versicolor:50  
 virginica :50  
                
                
                </code></pre>
<div id="taking-subsets-out-of-a-data-frame" class="section level3">
<h3>Taking subsets out of a data frame</h3>
<p>As we have already seen, the dollar sign is used to designate a field
from a data frame:</p>
<pre class="r"><code>&gt; iris$Sepal.Length</code></pre>
<pre><code>  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1
 [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0
 [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5
 [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1
 [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5
 [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3
[109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2
[127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8
[145] 6.7 6.7 6.3 6.5 6.2 5.9</code></pre>
<p>Note that we could also use the good old square bracket notation to
select that column: a data frame resembles a matrix where column are not
designated with their indices, but with names (strings of
characters):</p>
<pre class="r"><code>&gt; iris[,&#39;Sepal.Length&#39;]</code></pre>
<pre><code>  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1
 [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0
 [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5
 [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1
 [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5
 [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3
[109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2
[127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8
[145] 6.7 6.7 6.3 6.5 6.2 5.9</code></pre>
<p>Selecting a range of lines works, as the lines (or records) in a data
frame are numbered:</p>
<pre class="r"><code>&gt; iris[50:54,]</code></pre>
<pre><code>   Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
50          5.0         3.3          1.4         0.2     setosa
51          7.0         3.2          4.7         1.4 versicolor
52          6.4         3.2          4.5         1.5 versicolor
53          6.9         3.1          4.9         1.5 versicolor
54          5.5         2.3          4.0         1.3 versicolor</code></pre>
<p>What if we now want to select some of the records (lines), based on
some test(s) on their content? Below we extract all the records
(i.e. lines, corresponding to specimens) for which the length of the
sepal is at least 7.7. Note that nothing follows the comma enclosed in
the square brackets: we select all columns.</p>
<pre class="r"><code>&gt; iris[iris$Sepal.Length&gt;=7.7,]</code></pre>
<pre><code>    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
118          7.7         3.8          6.7         2.2 virginica
119          7.7         2.6          6.9         2.3 virginica
123          7.7         2.8          6.7         2.0 virginica
132          7.9         3.8          6.4         2.0 virginica
136          7.7         3.0          6.1         2.3 virginica</code></pre>
<p>Selecting lines with criteria calculated among several columns is
also possible. Below we select all the records where the sepal length is
greater or equal than 7.7 AND the petal length is strictly greater than
6.5. The logical AND operator is written <code>&amp;</code>, while the
logical OR is <code>|</code> and the logical NOT writes <code>!</code>
(prepended):</p>
<pre class="r"><code>&gt; b &lt;- iris[iris$Sepal.Length&gt;=7.7 &amp; iris$Petal.Length&gt;6.5,]
&gt; b</code></pre>
<pre><code>    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
118          7.7         3.8          6.7         2.2 virginica
119          7.7         2.6          6.9         2.3 virginica
123          7.7         2.8          6.7         2.0 virginica</code></pre>
<p>Note that the resulting object is still a data frame, where the
original <strong>names</strong> of the records have remained:</p>
<pre class="r"><code>&gt; is.data.frame(b)</code></pre>
<pre><code>[1] TRUE</code></pre>
<pre class="r"><code>&gt; b[1,]</code></pre>
<pre><code>    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
118          7.7         3.8          6.7         2.2 virginica</code></pre>
<pre class="r"><code>&gt; b[&#39;123&#39;,]</code></pre>
<pre><code>    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
123          7.7         2.8          6.7           2 virginica</code></pre>
<pre class="r"><code>&gt; b[,2]</code></pre>
<pre><code>[1] 3.8 2.6 2.8</code></pre>
<p>Here we see an interesting feature of data frames: their records
(lines) and fields (columns) are usually named with character strings,
but integer indices are still usable to address elements. If we want to
get only a subset of all columns in our resulting data frame, we use the
<code>subset</code> function:</p>
<pre class="r"><code>&gt; subset1 = subset(iris, Sepal.Length==5.1, select=Sepal.Width)
&gt; subset1</code></pre>
<pre><code>   Sepal.Width
1          3.5
18         3.5
20         3.8
22         3.7
24         3.3
40         3.4
45         3.8
47         3.8
99         2.5</code></pre>
<p>Above, the second argument of <code>subset</code> is the boolean
selection operator, while the third argument (<code>select</code>) trims
columns out of the output.</p>
<pre class="r"><code>&gt; subset1 = subset(iris,abs(Sepal.Length-5)&lt;=0.1,select=c(&#39;Sepal.Length&#39;,&#39;Sepal.Width&#39;))
&gt; subset1</code></pre>
<pre><code>    Sepal.Length Sepal.Width
1            5.1         3.5
2            4.9         3.0
5            5.0         3.6
8            5.0         3.4
10           4.9         3.1
18           5.1         3.5
20           5.1         3.8
22           5.1         3.7
24           5.1         3.3
26           5.0         3.0
27           5.0         3.4
35           4.9         3.1
36           5.0         3.2
38           4.9         3.6
40           5.1         3.4
41           5.0         3.5
44           5.0         3.5
45           5.1         3.8
47           5.1         3.8
50           5.0         3.3
58           4.9         2.4
61           5.0         2.0
94           5.0         2.3
99           5.1         2.5
107          4.9         2.5</code></pre>
<p>Here we use the <code>subset</code> command to extract the specimens
with a sepal length less than 0.1 away from 5.0, and on these we select
only the two columns relative to sepal dimensions.</p>
</div>
</div>
<div id="combining-rows-and-columns" class="section level2">
<h2>Combining rows and columns</h2>
<p>In R, two very generic commands exist that allow you to combine data
row-wise or column-wise. They are called respectively <code>rbind</code>
and <code>cbind</code>. With <code>cbind</code> you may for instance add
an additional column to a dataframe. With <code>rbind</code> you could
for instance concatenate the records of two similar arrays of data into
a single one. Let’s start with a simple example, say you want to add as
a first column of the dataframe <code>iris</code> random id numbers for
every specimen. We will use the random number generation function
<code>runif</code>, with no guarantee not to get duplicates, though. On
the first line below, <code>runif(150, min=1, max=100000</code>
generates a series of 150 numbers from the uniform probability
distribution on the interval <span class="math inline">\([1,
100000]\)</span>. Of these random numbers, <code>floor</code> gives the
numerical floor (largest integer value no greather than). We then
combine this new column with the existing <code>iris</code> data
frame:</p>
<pre class="r"><code>&gt; my_column = floor(runif(150, min=1, max=100000))
&gt; cbind(my_column, iris) -&gt; iris2
&gt; str(iris2)</code></pre>
<pre><code>&#39;data.frame&#39;:   150 obs. of  6 variables:
 $ my_column   : num  46699 98838 2671 20467 69370 ...
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
<p>Pay attention that the additional column is automatically named by
the name of the source. You can always alter the column names later on,
accessing these by the <code>names()</code> function, which can be use
to output <strong>or</strong> to input the names:</p>
<pre class="r"><code>&gt; names(iris2) -&gt; oldnames
&gt; oldnames[1] &lt;- &quot;ID&quot;
&gt; names(iris2) &lt;- oldnames</code></pre>
<p>You can add additional rows to an existing dataframe with
<code>rbind</code>, for instance adding the column averages to any
dataframe made of numeric values:</p>
<pre class="r"><code>&gt; av1 = mean(iris2[,1]);av2=mean(iris2[,2])
&gt; av3=mean(iris2[,3]);av4=mean(iris2[,4]);av5=mean(iris2[,5])
&gt; av6=names(which.max(table(iris2[,6]))) # # to get the most common category in this factor
&gt; rbind(iris2,c(av1,av2,av3,av4,av5,av6)) -&gt; iris3
&gt; tail(iris3, n=2)</code></pre>
<pre><code>                  ID     Sepal.Length      Sepal.Width Petal.Length
150            59727              5.9                3          5.1
151 49989.3066666667 5.84333333333333 3.05733333333333        3.758
         Petal.Width   Species
150              1.8 virginica
151 1.19933333333333    setosa</code></pre>
<p>So it seems that we are fine: the line containing the average values
of all the columns has been added at the bottom of the dataframe. But
let’s look at the structure of our new <code>iris3</code> variable:</p>
<pre class="r"><code>&gt; str(iris3)</code></pre>
<pre><code>&#39;data.frame&#39;:   151 obs. of  6 variables:
 $ ID          : chr  &quot;46699&quot; &quot;98838&quot; &quot;2671&quot; &quot;20467&quot; ...
 $ Sepal.Length: chr  &quot;5.1&quot; &quot;4.9&quot; &quot;4.7&quot; &quot;4.6&quot; ...
 $ Sepal.Width : chr  &quot;3.5&quot; &quot;3&quot; &quot;3.2&quot; &quot;3.1&quot; ...
 $ Petal.Length: chr  &quot;1.4&quot; &quot;1.4&quot; &quot;1.3&quot; &quot;1.5&quot; ...
 $ Petal.Width : chr  &quot;0.2&quot; &quot;0.2&quot; &quot;0.2&quot; &quot;0.2&quot; ...
 $ Species     : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
<p>What happened here? Furtively, all the numeric variables have been
converted to string (values of mode “character”). This is very
interesting to explain here, as it draws from the differencies between
data types in R.</p>
<p>First of all, we have to be aware that <strong>vectors</strong>
(built for instance through the use of the <code>c</code> command)
<strong>cannot contain mixed data types</strong>. Whenever one wants to
build a vector from data of different modes, R automatically coerce some
of the data to the most generic mode (usually the “character” mode as
lots of basic objects accept conversion to strings by means of the
<code>as.character()</code> function). For instance, here:</p>
<pre class="r"><code>&gt; mode(av1)</code></pre>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>&gt; mode(av6)</code></pre>
<pre><code>[1] &quot;character&quot;</code></pre>
<pre class="r"><code>&gt; av1</code></pre>
<pre><code>[1] 49989.31</code></pre>
<pre class="r"><code>&gt; c(av1,av2,av3,av4,av5,av6) -&gt; last_row
&gt; last_row</code></pre>
<pre><code>[1] &quot;49989.3066666667&quot; &quot;5.84333333333333&quot; &quot;3.05733333333333&quot; &quot;3.758&quot;           
[5] &quot;1.19933333333333&quot; &quot;setosa&quot;          </code></pre>
<pre class="r"><code>&gt; mode(last_row)</code></pre>
<pre><code>[1] &quot;character&quot;</code></pre>
<p><code>last_row</code>, as an R vector, has only one single mode: here
it is made of strings. Very logically then, when we used
<code>rbind</code> to concatenate this row to the <code>iris2</code>
table, the contagion spread to the dataframe because we were adding
character values to columns formerly of numeric mode.</p>
</div>
</div>
<div id="data-inputoutput-in-r-fromto-files" class="section level1">
<h1>Data input/output in R: from/to files</h1>
<p>Most frequently your work session with R will start with importing
some data from a datafile that you have somewhere on your computer. We
are going to see how to build an R object from a file, filling the
object (it will be that data structure R calls a <strong>table</strong>)
with the data present in that file.</p>
<div id="current-working-directory" class="section level2">
<h2>Current working directory</h2>
<p>Whenever R is running, it has an internal variable indicating where
is its <strong>current working directory</strong>. If you invoked R from
a shell, it will usually be the current working directory of the shell
at the moment when you launched R. Otherwise it can be your home
directory, or any other directory where R has read and write
permissions. You may check what is R’s current working directory with
the function <code>getwd()</code>:</p>
<pre class="r"><code>&gt; getwd()      # obviously you will get a different value here...</code></pre>
<pre><code>[1] &quot;/home/jbde/Trainings/R/r-and-tidyverse-intro-ag-research&quot;</code></pre>
<pre class="r"><code>&gt; mydir = getwd()</code></pre>
<p>The current working directory may be set to some other value through
the <code>setwd</code> command:</p>
<pre class="r"><code>&gt; setwd(&quot;~&quot;)      # setting it to my home directory...
&gt; getwd()</code></pre>
<pre><code>[1] &quot;/home/jbde&quot;</code></pre>
<pre class="r"><code>&gt; setwd(mydir)    # setting the current directory back to original value</code></pre>
<p>Whenever you specify some filename during your R session, R will
search for that file <strong>from the current working
directory</strong>, unless of course you give it in the form of an
<strong>absolute path</strong> (i.e. starting at the root of the
filesystem, with an initial slash <code>/</code>). So if you just give
the name of a file (and not an absolute or relative path), R will expect
to find the file you’re talking about in its current working directory.
This is also where it will write files.</p>
</div>
<div id="the-generic-read.table-function" class="section level2">
<h2>The generic <code>read.table</code> function</h2>
<p>Although there are several specific R functions to read data from
files, these are nothing but static refinements of the generic
<code>read.table</code> function. We will thus focus on this latter
only. It is meant to read data from a file, according to some
specifications (whether there is a header line, what is the field
separator, etc) and writes the content into an R object called a
<strong>data frame</strong>.</p>
<p>As a first example of input file, let us take the file
<code>fev_dataset.txt</code> provided along with this tutorial. This
file contains 655 lines (one header line and 654 records). We reproduce
below its first 6 lines (for those who want to know, the shell command
to get this is <code>head -n 6 fev_dataset.txt</code>):</p>
<blockquote>
<p>Age FEV Ht Gender Smoke<br />
9 1.7080 57.0 0 0<br />
8 1.7240 67.5 0 0<br />
7 1.7200 54.5 0 0<br />
9 1.5580 53.0 1 0<br />
9 1.8950 57.0 1 0</p>
</blockquote>
<p>Each line comprises 5 fields:</p>
<ol style="list-style-type: decimal">
<li>age in years,</li>
<li>FEV (Forced Expiratory Volume) expressed in liters,</li>
<li>height in inches,</li>
<li>gender (boys are coded 1, girls 0),</li>
<li>whether the kid is exposed to smoking in their family environment
(also a binary 0/1 variable).</li>
</ol>
<p>This dataset comes from a study originally performed by Rosner and
colleagues to find out whether constant exposure to an environment where
at least one of the parents is smoking had an impact on the respiratory
capacity of young boys and girls. Or course, the age and height of a
child are expected to play a significant role in the determination of
the pulmonary capacity of that same child, hence the presence of these
variables among the data collected.</p>
<p>Let us first try and use the simplest form of the function
<code>read.table</code>:</p>
<pre class="r"><code>&gt; read.table(&quot;fev_dataset.txt&quot;) -&gt; dat1</code></pre>
<p>Okay, we have read the contents of the file and have stored it into a
new <strong>data frame</strong> we called <code>dat1</code>. As R keeps
silent after this, let us check that this worked as expected. As two
exploratory content-checking commands, you may use <code>head</code> (to
first items of a data structure) or <code>str</code> (to get an
informative output concerning the internal structure of the object you
query):</p>
<pre class="r"><code>&gt; is.data.frame(dat1)</code></pre>
<pre><code>[1] TRUE</code></pre>
<pre class="r"><code>&gt; head(dat1)</code></pre>
<pre><code>   V1     V2   V3     V4    V5
1 Age    FEV   Ht Gender Smoke
2   9 1.7080 57.0      0     0
3   8 1.7240 67.5      0     0
4   7 1.7200 54.5      0     0
5   9 1.5580 53.0      1     0
6   9 1.8950 57.0      1     0</code></pre>
<pre class="r"><code>&gt; str(dat1)</code></pre>
<pre><code>&#39;data.frame&#39;:   655 obs. of  5 variables:
 $ V1: chr  &quot;Age&quot; &quot;9&quot; &quot;8&quot; &quot;7&quot; ...
 $ V2: chr  &quot;FEV&quot; &quot;1.7080&quot; &quot;1.7240&quot; &quot;1.7200&quot; ...
 $ V3: chr  &quot;Ht&quot; &quot;57.0&quot; &quot;67.5&quot; &quot;54.5&quot; ...
 $ V4: chr  &quot;Gender&quot; &quot;0&quot; &quot;0&quot; &quot;0&quot; ...
 $ V5: chr  &quot;Smoke&quot; &quot;0&quot; &quot;0&quot; &quot;0&quot; ...</code></pre>
<p>Now, that’s <strong>bad</strong>: R has seen a file of 655 records,
not noticing that the first line is actually not a data record, but the
header containing the names of the different fields (or columns).
Instead R used an automatic naming convention, dubbing the columns
<code>V1</code>, <code>V2</code>, etc. Notice it automatically adds
row-naming numbers, also.</p>
<p>The output of the <code>str</code> function is even more informative:
we see that as R had to fit into the same column some textual data
(coming from the header) and some numerical data as well (the
measurement datapoints), it interpreted everything to be categorical
variables represented as strings. To correct this, we have to tell R
that the first line of the file should not be considered as a data
record but as a header, thus giving the names of the columns. This is
done through the <code>header</code> option that we set to
<code>TRUE</code>:</p>
<pre class="r"><code>&gt; read.table(&quot;fev_dataset.txt&quot;, header=TRUE) -&gt; dat1
&gt; head(dat1)</code></pre>
<pre><code>  Age   FEV   Ht Gender Smoke
1   9 1.708 57.0      0     0
2   8 1.724 67.5      0     0
3   7 1.720 54.5      0     0
4   9 1.558 53.0      1     0
5   9 1.895 57.0      1     0
6   8 2.336 61.0      0     0</code></pre>
<pre class="r"><code>&gt; str(dat1)</code></pre>
<pre><code>&#39;data.frame&#39;:   654 obs. of  5 variables:
 $ Age   : int  9 8 7 9 9 8 6 6 8 9 ...
 $ FEV   : num  1.71 1.72 1.72 1.56 1.9 ...
 $ Ht    : num  57 67.5 54.5 53 57 61 58 56 58.5 60 ...
 $ Gender: int  0 0 0 1 1 0 0 0 0 0 ...
 $ Smoke : int  0 0 0 0 0 0 0 0 0 0 ...</code></pre>
<p>All is fine now, as R correctly detected that the records contain
numerical values. If we really want to insist that the
<code>Gender</code> and <code>Smoke</code> variable be treated as
categorical, we can force the use of specific classes (or “types”) for
the different columns (the backslash character at the end of a
commandline is just to indicate that the said line continues
uninterrupted onto the next: the line break was necessary only to fit
the line into this pagewidth):</p>
<pre class="r"><code>&gt; read.table(&quot;fev_dataset.txt&quot;, header=TRUE, colClasses=c(&quot;integer&quot;,&quot;numeric&quot;,&quot;numeric&quot;,&quot;factor&quot;,&quot;factor&quot;)) -&gt; dat1
&gt; str(dat1)</code></pre>
<pre><code>&#39;data.frame&#39;:   654 obs. of  5 variables:
 $ Age   : int  9 8 7 9 9 8 6 6 8 9 ...
 $ FEV   : num  1.71 1.72 1.72 1.56 1.9 ...
 $ Ht    : num  57 67.5 54.5 53 57 61 58 56 58.5 60 ...
 $ Gender: Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 2 2 1 1 1 1 1 ...
 $ Smoke : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
<div id="field-separator" class="section level3">
<h3>Field separator</h3>
<p>It is important to consider that within your original file, some
characters mark the boundary between one field and the following, within
one record. These can be for instance tabulation characters (usually
represented <code>\t</code>), any number of consecutive white spaces,
commas (<code>,</code>), semicolons (<code>;</code>) or colons
(<code>:</code>). By default <code>read.table</code>’s field separator
is any “white space”, which means one or more spaces, tabs, newlines or
carriage returns. In case this is not suitable for your input file, you
have to specify the correct field separator by means of the
<code>sep</code> option: for a regular CSV file (Comma-Separated
Values), you would specify <code>sep=","</code> as an option to
<code>read.table</code>.</p>
</div>
<div id="decimal-separator" class="section level3">
<h3>Decimal separator</h3>
<p>Also important to consider is the decimal separator in use for
numerical data in your original datafile. Most people around the world
use the dot (<code>.</code>) as the decimal point, but you are not
without knowing that the convention in French-speaking countries is to
have the comma (<code>,</code>) as the decimal point. Such an encoding
would be correctly handled by R during importation when the user
specifies the decimal point through the <code>sep</code> option,
e.g.~<code>sep=","</code>.</p>
</div>
<div id="unknown-or-missing-values" class="section level3">
<h3>Unknown or missing values</h3>
<p>Sometimes your file contains missing values, for instance if you have
two consecutive commas (<code>,,</code>) in a CSV file using the comma
as a field separator. R understand this and uses a special token called
<code>NA</code> to encode missing values. Sometimes the people who
prepared the datafile also use another predefined token to indicate
missing values, for instance “Na”, “na” or “n/a”. In order for R to
translate these strings into its proper <code>NA</code> values, you have
to indicate the possible NA-coding strings by means of the
<code>na.strings</code> option. For instance:</p>
<pre class="r"><code>&gt; read.table(&quot;myfile.txt&quot;, header=TRUE, sep=&quot;,&quot;, na.strings=c(&quot;na&quot;, &quot;n/a&quot;))</code></pre>
<p>In this case any value completely missing (two consecutive field
separators), as well as any string “na” or “n/a” as a field value, will
be understood by R as a missing value and translated into the unique
appropriate R token <code>NA</code>.</p>
</div>
</div>
<div id="data-output-writing-into-a-file" class="section level2">
<h2>Data output: writing into a file</h2>
<p>Once you want to write some tabulated data (e.g.~a vector, matrix or
data frame) from R right into a file in your filesystem, you may use the
<code>write.table</code> function. For instance, to write the content of
an R data frame called <code>mydata</code> in your current working
session into a file that you wawnt to call <code>myfile</code> and write
into your current working directory, you will use:</p>
<pre class="r"><code>&gt; write.table(mydata, file=&quot;myfile&quot;)</code></pre>
<p>In this case, the file will be written using the default field
separator for <code>write.table</code>, which is a single space
character. You may explore the different formatting options by calling
the help of <code>write.table</code>. Most of them are the equivalent of
what you can find for the reciprocal <code>read.table</code>
function.</p>
</div>
<div id="caution-when-importing-excel-format-into-r"
class="section level2">
<h2>Caution when importing Excel format into R!</h2>
<p>While many people use an advanced spreadsheet software
(e.g. LibreOffice Calc, Apache OpenOffice Calc or Microsoft Excel) to
prepare their data, unfortunately it is not possible to read data into R
directly from any of the <code>.odt</code>, <code>.xls</code> or
<code>.xlsx</code> formats. This is mainly because these formats are
meant to accomodate complex data in several sheets, which possibly
cannot fit into one single R object. When you want to import some data
from such a format, you first have to convert it into some CSV format
(notice that the field separator can be any other character of your
choice, not necessarily a comma), using your favourite spreadsheet
software. You will then be able to read the simpler CSV format into R
with the <code>read.table</code> function.</p>
<p>For instance, after having transformed the file
<code>tutorial_data.xlsx</code> into a comma-separated file that you
call <code>tutorial_data_commasep.csv</code>, you would load in into a
<code>mydat</code> data frame in your R session using the following
command (the backslach character at the end of a commandline is just to
indicate that the said line continues uninterrupted onto the next: the
line breaks were necessary only to fit the lines into this
pagewidth):</p>
<pre class="r"><code>&gt; mydat=read.table(&quot;tutorial_data_commasep.csv&quot;,
+                    header=T,
+                    sep=&quot;,&quot;,
+                    colClasses=c(&quot;integer&quot;,&quot;factor&quot;,&quot;integer&quot;,&quot;numeric&quot;,&quot;factor&quot;,
+                                 &quot;numeric&quot;,&quot;factor&quot;,&quot;integer&quot;,&quot;factor&quot;,&quot;factor&quot;))
&gt; knitr::knit_exit()</code></pre>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
